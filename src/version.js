/**
 * Protocol Version for YZ Network DHT
 *
 * This version is checked when clients connect to the bootstrap server.
 * If the client's version doesn't match the server's version, the connection
 * is rejected and the client is told to refresh their browser.
 *
 * There are TWO version components:
 * 1. PROTOCOL_VERSION - Semantic version for protocol compatibility
 *    - Manually increment when making breaking protocol changes
 *    - Allows backwards compatibility within major.minor versions
 *
 * 2. BUILD_ID - Bundle contenthash for deployment synchronization
 *    - Same hash used by browser bundle filename (bundle.HASH.js)
 *    - Server reads from dist/bundle-hash.json (generated by webpack)
 *    - Ensures browser and server are using the same deployment
 *
 * How it works:
 * 1. Webpack builds bundle.HASH.js and writes hash to dist/bundle-hash.json
 * 2. Browser extracts BUILD_ID from script src (bundle.HASH.js)
 * 3. Server reads BUILD_ID from dist/bundle-hash.json at startup
 * 4. Client connects to bootstrap and sends both values in registration
 * 5. Bootstrap checks:
 *    a) Protocol version compatibility (allows patch differences)
 *    b) Build ID match (must match for synchronized deployment)
 * 6. If mismatch, sends version_mismatch error with refresh instruction
 * 7. User refreshes ‚Üí browser fetches new bundle.js with updated hash
 * 8. Connection succeeds
 */

// Semantic version for protocol compatibility
export const PROTOCOL_VERSION = '1.0.0';

// Minimum compatible protocol version (for backwards compatibility)
export const MIN_COMPATIBLE_VERSION = '1.0.0';

/**
 * Build ID - Bundle contenthash for deployment synchronization
 *
 * Browser: Extracted from the bundle script filename (bundle.HASH.js)
 * Server: Read from dist/bundle-hash.json (generated by webpack build)
 *
 * Both browser and server use the SAME hash from the webpack build,
 * ensuring they're on the same deployment.
 */
let BUILD_ID_VALUE = 'initializing';

// Browser: Extract hash from bundle script src
if (typeof document !== 'undefined') {
  const scripts = document.getElementsByTagName('script');
  for (const script of scripts) {
    const src = script.src || '';
    const match = src.match(/bundle\.([a-f0-9]+)\.js/);
    if (match) {
      BUILD_ID_VALUE = match[1];
      break;
    }
  }
  if (BUILD_ID_VALUE === 'initializing') {
    BUILD_ID_VALUE = 'unknown_browser';
  }
} else {
  // Node.js: Read hash from bundle-hash.json (written by webpack)
  try {
    const fs = require('fs');
    const path = require('path');
    const hashFilePath = path.join(process.cwd(), 'dist', 'bundle-hash.json');
    if (fs.existsSync(hashFilePath)) {
      const data = JSON.parse(fs.readFileSync(hashFilePath, 'utf-8'));
      BUILD_ID_VALUE = data.hash;
      console.log(`üì¶ Loaded bundle hash from dist/bundle-hash.json: ${BUILD_ID_VALUE}`);
    } else {
      // No hash file - server started before build or build not run
      BUILD_ID_VALUE = `node_${Date.now()}`;
      console.log(`‚ö†Ô∏è No bundle-hash.json found, using fallback BUILD_ID: ${BUILD_ID_VALUE}`);
    }
  } catch (e) {
    BUILD_ID_VALUE = `node_${Date.now()}`;
    console.log(`‚ö†Ô∏è Error reading bundle-hash.json, using fallback BUILD_ID: ${BUILD_ID_VALUE}`);
  }
}

export const BUILD_ID = BUILD_ID_VALUE;

/**
 * Check if a client version is compatible with the server
 * @param {string} clientProtocolVersion - Client's protocol version (e.g., "1.0.0")
 * @param {string} clientBuildId - Client's build ID
 * @param {string} serverBuildId - Server's build ID (for comparison)
 * @returns {{ compatible: boolean, message?: string }}
 */
export function checkVersionCompatibility(clientProtocolVersion, clientBuildId, serverBuildId) {
  // Check protocol version first (allows patch differences)
  if (!clientProtocolVersion) {
    return {
      compatible: false,
      message: 'No protocol version provided. Please refresh your browser to get the latest version.'
    };
  }

  // Parse protocol versions (Major.Minor.Patch)
  const serverParts = PROTOCOL_VERSION.split('.').map(Number);
  const clientParts = clientProtocolVersion.split('.').map(Number);
  const minParts = MIN_COMPATIBLE_VERSION.split('.').map(Number);

  // Calculate version numbers for comparison
  const clientNum = clientParts[0] * 10000 + (clientParts[1] || 0) * 100 + (clientParts[2] || 0);
  const minNum = minParts[0] * 10000 + (minParts[1] || 0) * 100 + (minParts[2] || 0);

  // Check if client protocol version is below minimum
  if (clientNum < minNum) {
    return {
      compatible: false,
      message: `Your client version (${clientProtocolVersion}) is outdated. Server requires at least ${MIN_COMPATIBLE_VERSION}. Please refresh your browser to update.`
    };
  }

  // Require exact major.minor match for protocol (patch differences are OK)
  if (clientParts[0] !== serverParts[0] || clientParts[1] !== serverParts[1]) {
    return {
      compatible: false,
      message: `Protocol version mismatch. Client: ${clientProtocolVersion}, Server: ${PROTOCOL_VERSION}. Please refresh your browser to update.`
    };
  }

  // BUILD_ID checking: Enforce matching bundle hashes
  //
  // Both browser and server should have the SAME bundle hash from webpack build.
  // Browser extracts hash from bundle script src (bundle.HASH.js)
  // Server reads hash from dist/bundle-hash.json
  //
  // If either side has a fallback BUILD_ID (node_* or unknown_*), we skip the check
  // since the hash file wasn't available and we can't enforce matching.
  const isClientFallback = !clientBuildId ||
    clientBuildId.startsWith('node_') ||
    clientBuildId.startsWith('unknown_') ||
    clientBuildId === 'initializing';
  const isServerFallback = !serverBuildId ||
    serverBuildId.startsWith('node_') ||
    serverBuildId.startsWith('unknown_') ||
    serverBuildId === 'initializing';

  // Only enforce BUILD_ID match when both sides have valid bundle hashes
  if (!isClientFallback && !isServerFallback && clientBuildId !== serverBuildId) {
    return {
      compatible: false,
      message: `Bundle version mismatch. Please refresh your browser to get the latest version.`
    };
  }

  return { compatible: true };
}
